<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL | Portable Template</title>
  <style>
    html, body { background: #000; width: 100%; height: 100%; overflow: hidden; padding: 0; margin: 0; }
    #gameContainer { background: transparent !important; position: absolute; }
    #gameContainer canvas { position: absolute; width: 100%; height: 100%; }
    
    /* Pixel Art Scaling - keeps textures sharp */
    #gameContainer canvas[data-pixel-art="true"] {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      -ms-interpolation-mode: nearest-neighbor;
    }

    #loading-text {
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <canvas id="unity-canvas" data-pixel-art="true"></canvas>
    <div id="loading-text">INITIALIZING...</div>
  </div>

  <script src="Build/loader.js"></script>

  <script>
    // Configuration: Update these to match your file splitting
    const SETTINGS = {
      baseDir: "Build/",
      dataPartsCount: 2,    // How many parts you split data.br into
      wasmPartsCount: 2,    // How many parts you split wasm.br into
      aspectRatio: 960/540, // Original game resolution
      pixelArt: true
    };

    const loadingText = document.querySelector("#loading-text");
    let totalBytes = 0;
    let loadedBytes = 0;

    // Utility: Format bytes to readable strings
    function formatSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Network: Get file size via HEAD request
    async function getSize(url) {
      try {
        const res = await fetch(url, { method: "HEAD" });
        return parseInt(res.headers.get("Content-Length") || "0", 10);
      } catch { return 0; }
    }

    // Network: Fetch individual chunks and update progress
    async function fetchPart(url) {
      const response = await fetch(url);
      if (!response.body) {
        const ab = await response.arrayBuffer();
        loadedBytes += ab.byteLength;
        return new Uint8Array(ab);
      }
      const reader = response.body.getReader();
      const chunks = [];
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        loadedBytes += value.length;
        chunks.push(value);
        const percent = totalBytes > 0 ? ((loadedBytes / totalBytes) * 100).toFixed(1) : "?";
        loadingText.textContent = `DOWNLOADING: ${formatSize(loadedBytes)} / ${formatSize(totalBytes)} (${percent}%)`;
      }
      const full = new Uint8Array(chunks.reduce((acc, c) => acc + c.length, 0));
      let offset = 0;
      for (let chunk of chunks) { full.set(chunk, offset); offset += chunk.length; }
      return full;
    }

    // Logic: Combine parts into a single Blob URL
    async function mergeParts(parts, mimeType) {
      const buffers = await Promise.all(parts.map(p => fetchPart(SETTINGS.baseDir + p)));
      const blob = new Blob(buffers, { type: mimeType || undefined });
      return URL.createObjectURL(blob);
    }

    (async () => {
      try {
        // Define file lists
        const dataParts = Array.from({length: SETTINGS.dataPartsCount}, (_, i) => `data.br.part${i+1}`);
        const wasmParts = Array.from({length: SETTINGS.wasmPartsCount}, (_, i) => `wasm.br.part${i+1}`);
        const frameworkFile = "framework.js.br"; // Assuming compressed
        
        const allFiles = [...dataParts, ...wasmParts, frameworkFile];
        
        // Pre-calculate total size
        const sizes = await Promise.all(allFiles.map(f => getSize(SETTINGS.baseDir + f)));
        totalBytes = sizes.reduce((a, b) => a + b, 0);

        // Fetch and Reassemble
        const [dataUrl, wasmUrl, frameworkUrl] = await Promise.all([
          mergeParts(dataParts),
          mergeParts(wasmParts),
          mergeParts([frameworkFile], 'application/javascript')
        ]);

        // Handle Responsive Canvas
        const canvas = document.querySelector("#unity-canvas");
        function onResize() {
          const container = canvas.parentElement;
          let w = window.innerWidth;
          let h = window.innerHeight;
          if (w / h > SETTINGS.aspectRatio) {
            w = h * SETTINGS.aspectRatio;
          } else {
            h = w / SETTINGS.aspectRatio;
          }
          container.style.width = canvas.style.width = Math.floor(w) + "px";
          container.style.height = canvas.style.height = Math.floor(h) + "px";
          container.style.top = Math.floor((window.innerHeight - h) / 2) + "px";
          container.style.left = Math.floor((window.innerWidth - w) / 2) + "px";
        }
        window.addEventListener('resize', onResize);
        onResize();

        // Initialize Unity
        const config = {
          dataUrl: dataUrl,
          frameworkUrl: frameworkUrl,
          codeUrl: wasmUrl,
          streamingAssetsUrl: "StreamingAssets",
          companyName: "DefaultCompany",
          productName: "UnityGame",
          productVersion: "1.0",
        };

        createUnityInstance(canvas, config, (progress) => {
          loadingText.textContent = `BOOTING ENGINE: ${Math.round(progress * 100)}%`;
        }).then((instance) => {
          loadingText.remove();
        });

      } catch (err) {
        loadingText.textContent = 'CRITICAL ERROR: ' + err.message;
        console.error(err);
      }
    })();
  </script>
</body>
</html>
